# Быстрая сортировка / Quicksort

- Выбрать из массива элемент, называемый опорным(pivot). Это может быть любой из элементов массива. От выбора опорного
элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность. В ранних
реализациях, как правило, опорным выбирался первый элемент, что снижало производительность на отсортированных массивах.
Для улучшения эффективности может выбираться средний, случайный элемент или (для больших массивов) медиана первого,
среднего и последнего элементов. Медиана всей последовательности является оптимальным опорным элементом, но её
вычисление слишком трудоёмко для использования в сортировке.
- Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных
отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие». На практике массив обычно делят не
на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так
как упрощает алгоритм разделения
- Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка
больше единицы.

```php
<?php

/**
 * Worst O(n^2)
 * Average O(n logn)
 * Best  O(n logn)
 */ 
function quick(array $arr) : array {
    if (count($arr) < 2) {
        return $arr;
    } 
    
    $pivot = (int)(count($arr) / 2); // самый тупой выбор опорника 
    
    $less_arr = [];
    $more_arr = [];
    
    for ($i = 0; $i <count($arr); $i++) {
        if ($i == $pivot) {
            continue;
        }
        
        if ($arr[$i] < $arr[$pivot]) {
            $less_arr[] = $arr[$i];
        } else {
            $more_arr[] = $arr[$i];
        }
    }
     
    return array_merge(quick($less_arr), [$arr[$pivot]], quick($more_arr));
}

print_r(quick([3, 4, 1, 2, 5, 9, 6, 7, 8]));
```
